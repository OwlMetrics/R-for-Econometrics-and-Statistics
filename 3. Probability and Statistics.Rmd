---
title: "**`3. Probability and Statistics`**"
output: html_document
---

### **`3.1 R Functions for Probability Distributions`**

***
R's `stats` package provides probability density/mass function (pdf/pmf), cumulative distribution function (cdf), quantile function and (pseudo-) random number generator for a wide range of common probability distributions. One can call these built-in functions through prefixing a specific distribution name (abbreviation) by `d` for pdf/pmf, `p` for cdf, `q` for quantile, and `r` for random draws. For a comprehensive introduction to R's probability functions, see [CRAN Task View: Probability Distributions](https://cran.r-project.org/web/views/Distributions.html). 
```{r}
# pmf of Binomial(5,0.7) evaluated at 3
dbinom(3, size = 5, prob = 0.7) 
# pdf of N(0,1) evaluated at (0, .25, .5, .75, 1)
dnorm(seq(from = 0, to = 1, length = 5), mean = 0, sd = 1)
# 99% percentile of F(2,5)
qf(0.01, 2, 5, lower.tail = F)  
# probability of two-sided t(3) tails
2*pt(-2.43, df = 3) 
# 5 random draws from N(0,1)
rnorm(5, mean = 0, sd = 1)                                   
```

### **`3.2 Simulation`**

***
In econometric and statistical studies, one often needs to implement a statistical procedure to a simulated system. R comes with a set of random number generators that allow one to produce the random samples of the system. Random samples of various standard univariate distributions can be drawn using the `r` functions as shown in Section 3.1. I

It is often important to draw random (correlated) samples from a multivariate distribution. For multivariate normal distribution, one can use the `mvrnorm()` function in the `MASS` package.
```{r}
# random draws from MVN((0,0),[1,0.5;0.5,1])
library(MASS)
mu <- c(0, 0)
sigma <- diag(2)/2 + .5*matrix(1, nrow = 2, ncol = 2)
mvrnorm(n = 5, mu, sigma) 
```
To draw random samples from a general multivariate distribution, one can consider the `genCorGen()` function in the `simstudy` package[^1]

[^1]: One should first load the `data.table` package along with the `simstudy` package before using the `genCorGen()` function.
```{r}
# random draws from Unif[0,1] and Unif[-1,1] with correlation 0.5
library(data.table)
library(simstudy)
genCorGen(n = 5, nvars = 2, params1 = c(0, -1), params2 = c(1, 1),
          dist = "uniform", corMatrix = sigma, wide = T)
```

When simulating random numbers, it is often desirable to set a random number seed (an integer) to ensure reproducibility of the sequence of random numbers and the according simulation results. One can set random number seeds using the `set.seed()` function.
```{r}
set.seed(1) 
rnorm(5, mean = 0, sd = 1)
set.seed(1) 
rnorm(5, mean = 0, sd = 1)
```

### **`3.3 Resampling Methods`**

***
The `sample()` function draws randomly from a specified vector of numbers allowing one to resample from existing observations.
```{r}
# sample with replacement
x <- c(1:10)
sample(x, size = 8, replace = T)
# sample without replacement, size <= length(x)
sample(x, size = 8, replace = F)
# sample with specified probability weights
Pr <- c(.5, .2, .2, .1, 0, 0, 0, 0, 0, 0)
sample(x, size = 8, replace = T, prob = Pr)
# do random permutation if the "size" argument is not specified and length(x) > 1
sample(x)                                                      
# sample from 1:floor(x) if x is a scalar greater than 1
sample(5.5, size = 8, replace = T)
```

More complicated sampling, such as rows from a data frame or a list, can be done by applying `sample()` to the indices.
```{r}
X <- cbind(seq(1:3), seq(1:3))
X[sample(1:nrow(X), size = 5, replace = T),]
```

However, it is often more convenient and reliable to do resampling with the `boot()` function in the `boot` package. One can use `boot()` to generate R bootstrap replicates of a statistic applied to a data. The following code generates 500 bootstrap replicates to compute the 99% confidence interval (CI) of the sample median (statistic) based on a $\chi^2_{4}$ sample (data). By default, R does ordinary nonparametric bootstrap. For alternative resampling methods, check the `sim` argument of the `boot()` function.
```{r}
library(boot)
X <- rchisq(500, 4)
# define a median function with one argument for row index
f <- function(data, index) {median(data[index])}
median.boot <- boot(X, statistic = f, R = 500)
median.boot
str(median.boot)
# take a look at the first couple of bootstrap replicates
head(median.boot$t)
```

Then the bootstrap CI can be easily obtained using the `boot.ci()` function.
```{r}
boot.ci(median.boot, conf = 0.99)
```
 
### **`3.4 Empirical Distributions`**

***
With a set of observations, one can compute the empirical cdf using the `ecdf()` function. 
```{r}
# compute and plot the empirical cdf, compare it with the cdf of N(0,1) 
t <- rt(200, df = 3)
plot(ecdf(t), do.points = F, verticals = F)             
z <- seq(-7, 7, .01)
lines(z, pnorm(z, 0, 1), lwd = 2, col = "red")          
```

Similarly, one can also compute and plot the kernel density function using the `density()` function along with the histogram.
```{r}
# histogram
hist(t, freq = F, breaks = 20, xlim = c(-7, 7), ylim = c(0,0.45))    
# empirical density
lines(density(t), col = "blue", lwd = 2)    
# N(0,1) density
lines(z, dnorm(z, 0, 1), lwd = 2, col = "red") 
# show actual data points
rug(t) 
```

A better way to examine the distribution of data is to draw a QQ plot. One can use the `qqnorm()` function to create a normal QQ plot, and use the `qqline()` function to add a line for a “theoretical”, by default normal, QQ plot which passes through (by default) the first and third quantiles of the data.
```{r}
qqnorm(t)                                               
qqline(t)                                               
```

QQ plot can also be drawn against a (arbitrary) generated distribution using the `ppoints()` function.
```{r}
qqplot(qt(ppoints(220), df = 7), t)                     
qqline(t)
```

### **`3.5 Tests`**

***
One can perform a wide variety of statistical tests in R. Here let's use the `t.test()` function for one/two/paired sample t-test to show how to conduct a statistical test and retrieve the test results using R. 
```{r}
X <- rnorm(100)
# one-sample t-test with confidence level = 99%
t.test(X, mu = 1, conf.level = .99)                    
test1 <- t.test(X, mu = 1, conf.level = .99)
# return a list of t-test attributes
attributes(test1)
# retrieve p-value
test1$p.value 
```
```{r}
Y <- rnorm(100, 0, 2)
# two-sample, one-tailed t-test with H1: E(X) > E(Y), 'conf' is a shortcut for 'conf.level'
test2 <- t.test(X, Y, mu = 0, alt = "greater", conf = .9) 
# retrieve CI
test2$conf.int
```
```{r}
# paired t-test
test3 <- t.test(X, Y, mu = 0, paired = T, conf = .9)  
# retrieve t-statistic
test3$statistic
```

Many popular tests can be conducted in R using the class of `.test` functions. See also `wilcox.test()`, `chisq.test()`, `fisher.test()`, `shapiro.test()`, etc.
